<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Picasso源码分析(一)：整体加载流程</title>
    <link href="/2020/04/04/Picasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-%EF%BC%9A%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/"/>
    <url>/2020/04/04/Picasso%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E4%B8%80-%EF%BC%9A%E6%95%B4%E4%BD%93%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Picasso的使用"><a href="#Picasso的使用" class="headerlink" title="Picasso的使用"></a>Picasso的使用</h3><pre><code class="java">Picasso.get()       .load()       .into(mTestView);</code></pre><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><ul><li>get()方法是Picasso的入口方法（之前的入口方法为with(context)），通过此方法获得了一个Picasso对象</li></ul><pre><code class="java">@SuppressLint(&quot;StaticFieldLeak&quot;) static volatile Picasso singleton = null;public static Picasso get() {    if (singleton == null) {      synchronized (Picasso.class) {        if (singleton == null) {          if (PicassoProvider.context == null) {            throw new IllegalStateException(&quot;context == null&quot;);          }          singleton = new Builder(PicassoProvider.context).build();        }      }    }    return singleton;  }</code></pre><ul><li>get()方法采取了单例模式，与with(context)相比，Picasso内部进行了优化，利用PicassoProvider得到了一个context，PicassoProvider中的代码非常简单，PicassoProvider继承了ContentProvider，通过ContentProvider在初始化时（onCreate()）对context进行初始化</li><li>从上述源码可以看出Picasso的实例并不是通过new出来的，而是通过Builder类创建出来的，为什么要调用此写法，我们下面进行分析</li></ul><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><ul><li><p>Builder类是Picasso类中的一个静态内部类</p></li><li><p>get()方法中调用的Builder构造器代码如下</p><pre><code class="java">public Builder(@NonNull Context context) {      if (context == null) {        throw new IllegalArgumentException(&quot;Context must not be null.&quot;);      }      this.context = context.getApplicationContext();    }</code></pre><ul><li><p>看到上述代码我最初有个疑问，既然context都作为参数传递进Builder了，那为什么对Builder类中的context进行初始化的时候要调用context.getApplicationContext()</p><ul><li>首先我们需要简单的复习一下context<ul><li>context可以翻译为环境，在加载资源，获取系统服务等都需要他</li><li>Activity，Service，Application均为context的子类，所以在activity中，有些方法需要context作为参数，而我们只需传入activity.this就可以了</li><li>一个进程中其context的数量为：activity数量 + service数量 + 1（与进程生命周期一样的context）</li><li>需要注意的是：<strong>各个context的生命周期并不相同</strong>，activity表示的context其生命周期与activity的生命周期一样（service同理）</li></ul></li><li>接下来回归正题：Builder是Picasso类中的一个public修饰的静态内部类，我们可以在外部创建这个Builder类的对象来自定义Picasso中的缓存，图片的配置，以及线程池等等。创建这个Builder对象就需要以context作为参数，那么问题来了，context是调用者传入的，关于context的生命周期是无法确定的（比如传入了一个activity.this），这样就会导致Picasso持有这个activity的引用，当activity被回收时就可能发生内存泄漏，所以这里需要调用getApplicationContext()方法来获取一个全局的context</li></ul></li></ul></li></ul><h5 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h5><pre><code class="java">public Picasso build() {      Context context = this.context;      if (downloader == null) {        downloader = new OkHttp3Downloader(context);//下载器      }      if (cache == null) {        cache = new LruCache(context);//缓存      }      if (service == null) {        service = new PicassoExecutorService();      }      if (transformer == null) {        transformer = RequestTransformer.IDENTITY;      }      Stats stats = new Stats(cache);    //事件分发器      Dispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);      return new Picasso(context, dispatcher, cache, listener, transformer, requestHandlers, stats,          defaultBitmapConfig, indicatorsEnabled, loggingEnabled);    }</code></pre><h4 id="new-Picasso"><a href="#new-Picasso" class="headerlink" title="new Picasso()"></a>new Picasso()</h4><ul><li><p>由build()源码可以看出最终来生成Picasso实例的是Picasso这个类中的一个多参数的构造器，其代码如下</p><pre><code class="java">Picasso(Context context, Dispatcher dispatcher, Cache cache, Listener listener, RequestTransformer requestTransformer, List&lt;RequestHandler&gt; extraRequestHandlers, Stats stats, Bitmap.Config defaultBitmapConfig, boolean indicatorsEnabled, boolean loggingEnabled) {    this.context = context;    this.dispatcher = dispatcher;    this.cache = cache;    this.listener = listener;    this.requestTransformer = requestTransformer;    this.defaultBitmapConfig = defaultBitmapConfig;    int builtInHandlers = 7; // Adjust this as internal handlers are added or removed.    int extraCount = (extraRequestHandlers != null ? extraRequestHandlers.size() : 0);    List&lt;RequestHandler&gt; allRequestHandlers = new ArrayList&lt;&gt;(builtInHandlers + extraCount);    allRequestHandlers.add(new ResourceRequestHandler(context));    if (extraRequestHandlers != null) {      allRequestHandlers.addAll(extraRequestHandlers);    }    allRequestHandlers.add(new ContactsPhotoRequestHandler(context));    allRequestHandlers.add(new MediaStoreRequestHandler(context));    allRequestHandlers.add(new ContentStreamRequestHandler(context));    allRequestHandlers.add(new AssetRequestHandler(context));    allRequestHandlers.add(new FileRequestHandler(context));    allRequestHandlers.add(new NetworkRequestHandler(dispatcher.downloader, stats));    requestHandlers = Collections.unmodifiableList(allRequestHandlers);    this.stats = stats;    this.targetToAction = new WeakHashMap&lt;&gt;();    this.targetToDeferredRequestCreator = new WeakHashMap&lt;&gt;();    this.indicatorsEnabled = indicatorsEnabled;    this.loggingEnabled = loggingEnabled;    this.referenceQueue = new ReferenceQueue&lt;&gt;();    this.cleanupThread = new CleanupThread(referenceQueue, HANDLER);    this.cleanupThread.start();  }</code></pre><ul><li>首先注意Picasso中此构造器的修饰符，他是默认的修饰符，那么说明此构造器只能在Picasso这个包中调用，同时Picasso中没有其他构造器，那么由此可以得出，在使用Picasso时只能通过new Builder(context).build()方法来获取Picasso的实例</li></ul></li><li><p>其次这个构造器的作用就是将Picasso中的一些变量实例化，各个变量的作用可以通过其名称大致的猜出，当然后续的分析中也会具体的分析他们的作用，目前只需了解大概就可以了</p><ul><li>至此，Picasso第一步构建对象已经完成了</li></ul></li></ul><h3 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h3><ul><li><p>load()方法是一个重载的方法，其可以接收的参数为：String，File，Uri，ResourceId，但通过源码可以发现，其最终将String(Uri.parse(String))，File(Uri.fromFile(File))都转换为Uri来处理(调用了load(Uri)的方法，返回一个RequestCreator实例)，但ResourceId是直接调用RequestCreator的构造器</p></li><li><p>load()代码如下</p><pre><code class="java">public RequestCreator load(@Nullable Uri uri) {    return new RequestCreator(this, uri, 0);  }public RequestCreator load(@DrawableRes int resourceId) {    if (resourceId == 0) {      throw new IllegalArgumentException(&quot;Resource ID must not be zero.&quot;);    }    return new RequestCreator(this, null, resourceId);  }public RequestCreator load(@NonNull File file) {    //当File为空，Picasso会自动的创建一个RequestCreator，所以在调用Picasso的时候，我们可以不用对文件进行判空处理    if (file == null) {      return new RequestCreator(this, null, 0);    }    return load(Uri.fromFile(file));  }//传入String时，由源码可知，当String为空时，不会抛出异常，但当String的长度为0的时候，会抛出异常，所以我们调用此方法的时候应注意异常处理public RequestCreator load(@Nullable String path) {    if (path == null) {      return new RequestCreator(this, null, 0);    }    if (path.trim().length() == 0) {      throw new IllegalArgumentException(&quot;Path must not be empty.&quot;);    }    return load(Uri.parse(path));  }</code></pre></li></ul><h3 id="Requestor"><a href="#Requestor" class="headerlink" title="Requestor"></a>Requestor</h3><ul><li><p>Requestor是Picasso包中独立的类，其提供了两个构造方法，分别如下</p><pre><code class="java">RequestCreator(Picasso picasso, Uri uri, int resourceId) {    if (picasso.shutdown) {      throw new IllegalStateException(          &quot;Picasso instance already shut down. Cannot submit new requests.&quot;);    }    this.picasso = picasso;    this.data = new Request.Builder(uri, resourceId, picasso.defaultBitmapConfig);  }  @VisibleForTesting RequestCreator() {    this.picasso = null;    this.data = new Request.Builder(null, 0, null);  }</code></pre><ul><li>由上源码可以看出，其中初始化了Request.Builder类，Builder类是Request类的一个用final修饰的静态内部类</li><li>至此，load方法的流程就先看到这里，其最终返回了一个RequestCreator对象，我们发现，无论是get还是load，Picasso始终都只是在进行初始化的操作，并未有逻辑在里面，所以逻辑应该是出现在into里面</li></ul></li></ul><h3 id="into"><a href="#into" class="headerlink" title="into()"></a>into()</h3><ul><li><p>into()方法的作用由这个词本身可以猜测出来，将图片加载进这个容器中</p></li><li><p>into()方法也是出现了这样的一个方法重载，追踪其源码会发现最终调用了这两个into()方法</p><pre><code class="java">public void into(ImageView target, Callback callback) {    //此方法以毫微秒为单位，只能用于测量已过的时间，与系统或钟表时间的其他任何时间概念无关，返回值表示从某一固定但任意的时间算起的毫微秒数（或许从以后算起，所以该值可能为负，不能进行时间转换    //System.currentTimeMillis返回从1970.01.01UTC零点开始到现在的时间，精确到毫秒，可以转换为确切的日期    long started = System.nanoTime();    checkMain();//此方法用于检测当前线程是否处于主线程，若不是主线程将会报错    if (target == null) {      throw new IllegalArgumentException(&quot;Target must not be null.&quot;);    }    //hasImage顾名思义其作用就是判断当前是否有图片，这个方法是通过判断当前是否有图片的URI或者ResorceID来判断是否有图片    //如果没有图片，就取消此次请求，并且如果有占位图的话就设置占位图    if (!data.hasImage()) {      picasso.cancelRequest(target);      if (setPlaceholder) {        setPlaceholder(target, getPlaceholderDrawable());      }      return;    }    if (deferred) {        //deferred只有在调用了fit方法时才会为true，所以一旦调用了fit方法，就不再允许调用者再次设置图片的大小      if (data.hasSize()) {        throw new IllegalStateException(&quot;Fit cannot be used with resize.&quot;);      }      int width = target.getWidth();      int height = target.getHeight();      if (width == 0 || height == 0) {        if (setPlaceholder) {          setPlaceholder(target, getPlaceholderDrawable());        }        picasso.defer(target, new DeferredRequestCreator(this, target, callback));        return;      }      data.resize(width, height);    }    Request request = createRequest(started);    String requestKey = createKey(request);    if (shouldReadFromMemoryCache(memoryPolicy)) {      Bitmap bitmap = picasso.quickMemoryCacheCheck(requestKey);//从缓存中获取图片      if (bitmap != null) {        picasso.cancelRequest(target);        setBitmap(target, picasso.context, bitmap, MEMORY, noFade, picasso.indicatorsEnabled);        if (callback != null) {          callback.onSuccess();        }        return;      }    }    if (setPlaceholder) {      setPlaceholder(target, getPlaceholderDrawable());    }    Action action =new ImageViewAction(picasso, target, request, memoryPolicy, networkPolicy, errorResId, errorDrawable, requestKey, tag, callback, noFade);    picasso.enqueueAndSubmit(action);}</code></pre><ul><li>由into(ImageView，Callback)方法可以总结出Picasso加载图片的过程：<ol><li>首先检查当前线程是否在主线程，若不在将会报错</li><li>检查当前设置View的imageView是否为空</li><li>检查是否设置图片资源，若没有设置图片资源，那么取消图片请求并设置占位图（如果存在占位图），然后返回</li><li>判断调用者是否设置fit属性（即图片大小设置为imageView的大小）<ul><li>首先检查是否设置了fit属性的同时调用了resize方法，若有则报错。</li><li>然后获取当前ImageView的宽高，若其中一者为0，则设置占位图（若有设置）调用defer方法</li><li>最后调用resize方法</li></ul></li><li>构造对应的request与requestKey</li><li>根据对应的缓存策略从内存中读取图片，若读取成功，则返回</li><li>查看是否设置了占位图</li><li>封装请求的action</li><li>将action进行提交</li></ol></li></ul></li></ul><h4 id="picasso-enqueueAndSubmit-Action-action"><a href="#picasso-enqueueAndSubmit-Action-action" class="headerlink" title="picasso.enqueueAndSubmit(Action action)"></a>picasso.enqueueAndSubmit(Action action)</h4><ul><li><p>这句代码出现在了into的最后，由名字可得出提交action，也就是说会对Action进行一个处理（加载图片啥的），对请求做处理的话一般都会涉及到事件分发，线程转换等等，那么在这里的话我们可以看到这个方法是在Picasso这个类里面的</p><p>那么Question来了，为什么不将代码直接写在RequestCreator这个类里面，而是要多此一举呢？（这是我之前也忽略了的部分，其实我之前写图片加载库的时候就直接把类似的方法写在了RequestCreator里面，有点憨），那我们接着来看这个方法中的代码</p><pre><code class="java">//Picasso类中void enqueueAndSubmit(Action action) {    //打问号，为什么要这么做    Object target = action.getTarget();    if (target != null &amp;&amp; targetToAction.get(target) != action) {      // This will also check we are on the main thread.      cancelExistingRequest(target);      targetToAction.put(target, action);    }    submit(action);  }void submit(Action action) {    dispatcher.dispatchSubmit(action);  }</code></pre></li><li><p>看到submit中的代码有木有突然醒悟的感jio，在Picasso里面是通过dispatcher进行事件分发，那么若在RequestCreator中直接进行事件分发，那RequestCreator中岂不是也得有dispatcher的引用吗，这样写也达到了一个解耦的目的（感觉自己是个傻逼）</p></li></ul><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><ul><li><p>关于Dispatcher这个类，我们从其在Picasso中的对象的初始化开始研究</p></li><li><p>在build()方法中</p><pre><code class="java">//service是一个线程池，downloader是一个利用OKHttp实现的下载器，cache是一个用于缓存的LruCache//HANDLER是一个主线程的handlerDispatcher dispatcher = new Dispatcher(context, service, HANDLER, downloader, cache, stats);</code></pre></li><li><p>在Dispatcher中其构造方法如下</p><pre><code class="java"> Dispatcher(Context context, ExecutorService service, Handler mainThreadHandler, Downloader downloader, Cache cache, Stats stats) {     //DispatcherThread是Dispatcher中的一个静态内部类，其继承了HandlerThread，相当于也是一个Thread     this.dispatcherThread = new DispatcherThread();     this.dispatcherThread.start();     this.hunterMap = new LinkedHashMap&lt;&gt;();     this.failedActions = new WeakHashMap&lt;&gt;();     this.pausedActions = new WeakHashMap&lt;&gt;();     this.pausedTags = new LinkedHashSet&lt;&gt;();     ...;     //DispatcherHandler继承于Handler由于此处传入Handler的Looper是子线程的Looper，所以此处handler的handleMessage是运行在子线程中的     this.handler = new DispatcherHandler(dispatcherThread.getLooper(), this);     //运行在主线程的Handler     this.mainThreadHandler = mainThreadHandler; }</code></pre></li><li><p>在dispatchSubmit中其处理事件的代码如下</p><pre><code class="java">void dispatchSubmit(Action action) {    handler.sendMessage(handler.obtainMessage(REQUEST_SUBMIT, action));}</code></pre><ul><li>由以上代码分析可知，我们已经由主线程转入了子线程</li></ul></li><li><p>在子线程处理的如下</p><pre><code class="java">@Override public void handleMessage(final Message msg) {      switch (msg.what) {        case REQUEST_SUBMIT: {          Action action = (Action) msg.obj;          dispatcher.performSubmit(action);//          break;            ...        }      }}void performSubmit(Action action, boolean dismissFailed) {    //判断该请求是否停止    if (pausedTags.contains(action.getTag())) {      pausedActions.put(action.getTarget(), action);      return;    }    BitmapHunter hunter = hunterMap.get(action.getKey());    //请记住这一行，后面有分析噢    if (hunter != null) {      hunter.attach(action);      return;    }    if (service.isShutdown()) {      return;    }    //获取了如何处理请求的处理器    hunter = forRequest(action.getPicasso(), this, cache, stats, action);    //在线程池中执行线程有两种方式，一个是execute，另一个是submit    //两者的区别：1. excute只能提交一个Runnable的对象，提交后，线程开始执行时就与主线程脱离了关系，当然也可以设置一些变量来获取线程运行的结果。但submit可以直接通过future来获取结果    //2. 若使用execute，当线程的执行过程中抛出了异常时主线程无法获取到信息，只有通过ThreadFactory主动设置线程的异常类才能感知；若使用submit，则可以通过future来直接获取到异常信息    hunter.future = service.submit(hunter);    hunterMap.put(action.getKey(), hunter);    if (dismissFailed) {      failedActions.remove(action.getTarget());    }  }</code></pre><pre><code class="java">//当从hunterMap中取出的hunter不为空时会调用此方法，在什么情况下hunter不为空//可能出现这样一种状况，现在有两个action，其对应的key是相同的，在这种情况下认为其对应了同一个hunter，但这两个action在某些方面是不同的，所以我们需要将action放入list中，void attach(Action action) {    boolean loggingEnabled = picasso.loggingEnabled;    Request request = action.request;    if (this.action == null) {      this.action = action;      return;    }    if (actions == null) {      actions = new ArrayList&lt;&gt;(3);    }    actions.add(action);    Priority actionPriority = action.getPriority();    if (actionPriority.ordinal() &gt; priority.ordinal()) {      priority = actionPriority;    }  }</code></pre></li></ul><pre><code class="java">  static BitmapHunter forRequest(Picasso picasso, Dispatcher dispatcher, Cache cache, Stats stats, Action action) {      Request request = action.getRequest();      List&lt;RequestHandler&gt; requestHandlers = picasso.getRequestHandlers();      //这里的代码的处理方式可以学习一下（哎呀，我忘了这种方式叫啥名了，尴尬）      for (int i = 0, count = requestHandlers.size(); i &lt; count; i++) {        RequestHandler requestHandler = requestHandlers.get(i);        if (requestHandler.canHandleRequest(request)) {          return new BitmapHunter(picasso, dispatcher, cache, stats, action, requestHandler);        }      }      //若没有找到对应的处理器，并没有直接的抛出异常，而是为此创建了一个错误的handler      return new BitmapHunter(picasso, dispatcher, cache, stats, action, ERRORING_HANDLER);    }  private static final RequestHandler ERRORING_HANDLER = new RequestHandler() {      @Override public boolean canHandleRequest(Request data) {        return true;      }      //层层向上抛出异常      @Override public Result load(Request request, int networkPolicy) throws IOException {        throw new IllegalStateException(&quot;Unrecognized type of request: &quot; + request);      }    };</code></pre><h3 id="BitmapHunter"><a href="#BitmapHunter" class="headerlink" title="BitmapHunter"></a>BitmapHunter</h3><pre><code class="java"> @Override public void run() {    try {      updateThreadName(data);      result = hunt();      if (result == null) {        dispatcher.dispatchFailed(this);      } else {        dispatcher.dispatchComplete(this);      }    } catch (NetworkRequestHandler.ResponseException e) {        ...    }  }</code></pre><pre><code class="java">Bitmap hunt() throws IOException {    Bitmap bitmap = null;    //从缓存中获取图片    if (shouldReadFromMemoryCache(memoryPolicy)) {      bitmap = cache.get(key);      if (bitmap != null) {        stats.dispatchCacheHit();        loadedFrom = MEMORY;        return bitmap;      }    }    networkPolicy = retryCount == 0 ? NetworkPolicy.OFFLINE.index : networkPolicy;    //调用图片加载器的对应的load方法，由于Picasso中支持从网络，文件，本地等获取图片，关于其具体的加载流程，后面会具体的写一篇的博客    RequestHandler.Result result = requestHandler.load(data, networkPolicy);    if (result != null) {      loadedFrom = result.getLoadedFrom();      exifOrientation = result.getExifOrientation();      bitmap = result.getBitmap();        //不同的图片加载器，获取图片的方式是不同的，如加载网络图片则返回图片的流而不是bitmap      if (bitmap == null) {        Source source = result.getSource();        try {          bitmap = decodeStream(source, data);        } finally {          try {            //noinspection ConstantConditions If bitmap is null then source is guranteed non-null.            source.close();          } catch (IOException ignored) {              ...          }        }      }    }    ...    return bitmap;  }</code></pre><h4 id="获取图片成功之后"><a href="#获取图片成功之后" class="headerlink" title="获取图片成功之后"></a>获取图片成功之后</h4><ul><li><pre><code class="java">if (result == null) {        dispatcher.dispatchFailed(this);      } else {        dispatcher.dispatchComplete(this);      }</code></pre><ul><li>由源码可以得出，将会通过dispatcher的dispatchComplete或dispatchFailed将事件传递出去</li></ul></li><li><p>先看dispatchComplete()中的代码</p><pre><code class="java">void dispatchComplete(BitmapHunter hunter) {    handler.sendMessage(handler.obtainMessage(HUNTER_COMPLETE, hunter));  }//dispatchComplete()方法中通过handler发送事件，需要注意的一点是此时调用的handler仍是子线程的handler，通过源码可以得出，在子线程的handler的handleMessage中再次调用了dispatcher的performComplete()方法，我们接下来直接分析performComplete()方法void performComplete(BitmapHunter hunter) {    //将图片写入缓存    if (shouldWriteToMemoryCache(hunter.getMemoryPolicy())) {      cache.set(hunter.getKey(), hunter.getResult());    }    //由于此时此hunter的请求已经结束了，所以将hunter从hunterMap中移除，那么从这里我们可以大致的得出这个hunterMap存在的意义：hunterMap是一个LinkedHashMap，它在这里的话也起到了一个缓存的意义，首先，在需要获取图片的时候，先从hunterMap中获取，是否有缓存，因为可能出现需要加载的这张图片之前已经生成过一个bitmapHunter了，只是之前的请求被暂停了的情形，而现在这张图片已经请求成功了，下一步这张图按照缓存策略可能将以其他的形式缓存（如利用LruCache）所以需要将这张图片从hunterMap中取出    hunterMap.remove(hunter.getKey());    batch(hunter);    }  }</code></pre><pre><code class="java">private void batch(BitmapHunter hunter) {    if (hunter.isCancelled()) {      return;    }    if (hunter.result != null) {      hunter.result.prepareToDraw();//构建所有与待画位图相关的缓存，在位图可清除的情况下，这个调用会努力保证像素已经被解码，就相当于现在已经被告知一定要加载这张图片，但我不知道具体什么时候加载这张图，我调用这个方法就是先让这张图提前解码（做好加载的准备），以便在需要加载时这张图可以直接加载而不需要解码（这个还需要具体的研究）    }    batch.add(hunter);    //为神马要延迟发送    //我的理解是：举个栗子：listView来实现照片墙的效果，我现在需要加载大量的图片，如果对于每一张图都利用handler来发送一条消息的话在一定程度上会造成资源的浪费，而现在我延迟几秒再次发送的话，会减少所发信息的数量，在一定的程度上提高运行速度    if (!handler.hasMessages(HUNTER_DELAY_NEXT_BATCH)) {      handler.sendEmptyMessageDelayed(HUNTER_DELAY_NEXT_BATCH, BATCH_DELAY);    }  }</code></pre></li><li><pre><code class="java">void performBatchComplete() {    List&lt;BitmapHunter&gt; copy = new ArrayList&lt;&gt;(batch);    batch.clear();  mainThreadHandler.sendMessage(mainThreadHandler.obtainMessage(HUNTER_BATCH_COMPLETE, copy));  }</code></pre></li></ul><h4 id="在Picasso中"><a href="#在Picasso中" class="headerlink" title="在Picasso中"></a>在Picasso中</h4><ul><li><p>在mainHandler得handleMessage中会调用这个以下方法</p><pre><code class="java">void complete(BitmapHunter hunter) {    Action single = hunter.getAction();    List&lt;Action&gt; joined = hunter.getActions();//关于actionList的由来上面解释过了噢    boolean hasMultiple = joined != null &amp;&amp; !joined.isEmpty();    boolean shouldDeliver = single != null || hasMultiple;    if (!shouldDeliver) {      return;    }    Uri uri = hunter.getData().uri;    Exception exception = hunter.getException();    Bitmap result = hunter.getResult();    LoadedFrom from = hunter.getLoadedFrom();    if (single != null) {      deliverAction(result, from, single, exception);    }    if (hasMultiple) {      //noinspection ForLoopReplaceableByForEach      for (int i = 0, n = joined.size(); i &lt; n; i++) {        Action join = joined.get(i);        deliverAction(result, from, join, exception);      }    }    if (listener != null &amp;&amp; exception != null) {      listener.onImageLoadFailed(this, uri, exception);    }  }</code></pre><pre><code class="java">private void deliverAction(Bitmap result, LoadedFrom from, Action action, Exception e) {    if (action.isCancelled()) {      return;    }    if (!action.willReplay()) {      targetToAction.remove(action.getTarget());    }    if (result != null) {      if (from == null) {        throw new AssertionError(&quot;LoadedFrom cannot be null.&quot;);      }      action.complete(result, from);      }    } else {      action.error(e);    }  }</code></pre><ul><li><p>deliverAction()方法是Picasso中用private修饰的方法，通过上述的代码可得出，</p></li><li><p>在Picasso中Action为抽象类，其complete(Bitmap, Picasso.LoadedFrom), error(Exception)方法均为抽象方法，FetchAction，RemoteViewAction， GetAction，TargetAction均为其子类（每个类的作用正在研究中），以这里我们以ImageViewAction为例进行分析</p><pre><code class="java"> @Override public void complete(Bitmap result, Picasso.LoadedFrom from) {    if (result == null) {      throw new AssertionError(          String.format(&quot;Attempted to complete action with no result!\n%s&quot;, this));    }    ImageView target = this.target.get();     //target采用的是弱引用，这里进行判空避免target被回收而造成的空指针异常    if (target == null) {      return;    }    Context context = picasso.context;    boolean indicatorsEnabled = picasso.indicatorsEnabled;     //由方法名可以得出Picasso是通过此方法来将图片设置进ImageView    PicassoDrawable.setBitmap(target, context, result, from, noFade, indicatorsEnabled);    if (callback != null) {        //callback是提供给外部的用于图片加载成功之后的回调      callback.onSuccess();    }  }</code></pre><ul><li><p>PicassoDrawable是Picasso中一个继承BitmapDrawable的final修饰的类</p></li><li><p>关于PicassoDrawable类中的setBitmap()方法，其作用是将Bitmap设置进ImageView，关于其具体分析后续我将再出一篇博文，现在就先写到这里啦</p></li><li><p>下面我们再来看看其出现异常时的处理</p><pre><code class="java">@Override public void error(Exception e) {    ImageView target = this.target.get();    if (target == null) {      return;    }    Drawable placeholder = target.getDrawable();    if (placeholder instanceof Animatable) {      ((Animatable) placeholder).stop();    }    if (errorResId != 0) {      target.setImageResource(errorResId);    } else if (errorDrawable != null) {      target.setImageDrawable(errorDrawable);    }    if (callback != null) {      callback.onError(e);    }  }</code></pre><ul><li>其具体的操作也非常简单，首先暂停占位图的动画（如果有占位图并且其有动画的话），然后设置错误加载图，最后再调用提供给外部的回调接口</li></ul></li></ul></li></ul></li></ul><h4 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h4><p>害，到这里整个Picasso的大概的流程就分析结束了（好像拖了很久了），整篇文的布局好像有点凌乱的鸭子（我下次一定好好注意，努力改正）如果中间出现错误或者分析不完整的地方还请大佬们多多指教！后面我将从缓存策略，图片处理等方面具体的分析一下Picasso（我尽量不拖）。今天就先写到这里辣，下期节目我们再见！（有木有很正式的感jio）拜拜！</p>]]></content>
    
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转角遇见Ma Belle</title>
    <link href="/2020/03/27/%E8%BD%AC%E8%A7%92%E9%81%87%E8%A7%81%E7%94%9C%E5%93%81%E5%BA%97/"/>
    <url>/2020/03/27/%E8%BD%AC%E8%A7%92%E9%81%87%E8%A7%81%E7%94%9C%E5%93%81%E5%BA%97/</url>
    
    <content type="html"><![CDATA[<p>Chen-JX终于发博客了，万万没想到发的第一篇博客居然是，吃的！主要是改bug改累了，然后就写写小博客轻松一下下。</p><p>出现在Chen-JX第一篇博客里的幸运儿是一家甜品店，没办法，甜品总是可以让人幸福感爆棚，特别是和爱的人一起，哈哈哈哈哈！</p><p>好了，说了一大段废话，上图！</p><ul><li><p><strong>焦糖杏仁蛋糕</strong></p><p><img src="/img/jiaotang.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>焦糖的微苦加上。。。（突然发现有点尴尬，因为我忘了，她外面的是什么了，然后，就不知道怎么形容了），因为，<strong>没钱</strong>，太久没吃了！（疯狂暗示）</li><li>章鱼小盆友超级超级喜欢这个蛋糕，当然，我也超级喜欢</li><li>这个蛋糕试过两次，第一次感觉不是特别习惯焦糖的微微苦的感觉，但是第二次，i了i了，盆友们如果要去试试这家店，一定要试试这个，不肥后悔哒！</li></ul></li></ul><ul><li><p><strong>海苔芝士奶盖戚风</strong></p><p><img src="/img/naigai.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>纠结了很久，到底是把焦糖放放在第一个还是海苔放在第一个，因为两个蛋糕都超级爱的，至于为神马要把这个放到第二勒</p><p>别问，问就是一大把狗粮！</p></li><li><p>喜欢奶盖的盆友，强推！</p></li></ul></li></ul><ul><li><p>抹茶流心卷</p><p><img src="/img/mocha.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>这是19年国庆和家希小姐妹去的时候点的，肿么说呢，这个蛋糕味道还是挺不错的吧，但没有让我感觉到特别的惊艳，就感觉甜品店都可以吃到这种抹茶蛋糕。所以呢，我jio得，这个蛋糕吧，可以点，但必要。</li></ul></li></ul><ul><li><p>白桃乌龙茶</p><ul><li><p>好了，现在来说说Chen-JX最后悔点的东西</p></li><li><p>这个茶，没有搅拌之前是这鸭子滴</p><p><img src="/img/before.jpg" srcset="/img/loading.gif" alt=""></p><ul><li>肿么说呢，味道淡淡的，不像平时喝的茶味道那么浓烈。上面的奶盖吧（记不清是不是奶盖了），味道也挺淡的，我不是特别喜欢，（不然，我肿么可能不把她喝完），她这么贵我都没把她喝完，味道嘛，你们自己体会一下哦！</li></ul></li></ul></li></ul><ul><li><p>大力搅拌了之后，是这个鸭子滴，展示一下陈同学大力出奇迹后的成果</p><p><img src="/img/now.jpg" srcset="/img/loading.gif" alt=""></p><ul><li><p>这颜色白得像不像纯牛奶，别看它长得像纯牛奶，味道嘛，也挺像纯牛奶的。excuse me，我花了二三十，去买了一杯纯牛奶。小盆友，你是不是有很多问号？？？</p></li><li><p>所以呢，你们就不要踩雷啦！当然，如果dl们想尝试一下二三十块一杯的纯牛奶到底是什么味道滴，也⑧四⑧行。反正，我是不想再去喝第二次了。</p></li><li><p>至于当时为神马要点这个，记得好像是和上面的哪个蛋糕是套餐来着，正巧又需要一杯喝的，于是。。。害，说着都是一把泪</p></li></ul></li></ul><p>好啦，因为Chen-JX只去过这家店两次（因为没钱），所以目前只试了这些啦！如果有大佬愿意带上小弟一起飞，我一定不会拒绝。（疯狂暗示）</p><p>想知道位置吗，求我啊！</p><p>体育西H出口右转，你就可以看见她啦！店面挺小的，但人还蛮多的，我去了两次两次都等了挺久的。小店装修挺温馨，感觉是网红店的风格，因为，她本来就是一家网红店啦！各位大佬如果想带上自己的男盆友女盆友些去吃吃甜品，这是一个好去处。但如果你想要找个地方约会的话，我jio得，这里就不是那么适合啦！（人比较多，有点吵，一般来说你们旁边都坐着有人，还肿么约会嘛，当然如果你们不介意的话，请忽略掉我的话）。对了二楼还有一个网红照相馆，大家可以去拍拍情侣照啥的，生活需要一点仪式感，不要像我一样佛系谈恋爱，不好！</p><p>好了，摸鱼摸完了，该去学习了，下一篇博文，应该就是一篇源码分析了吧，应该吧？？？</p>]]></content>
    
    
    
    <tags>
      
      <tag>甜品系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
